//----------------------------------- Main
use std::path::Path;
use swc_common::sync::Lrc;
use swc_common::{
    errors::{ColorConfig, Handler},
    FileName, FilePathMapping, SourceMap,
};
use swc_ecma_ast::Module;
use swc_ecma_codegen::{text_writer, Config, Emitter};
use swc_ecma_parser::{lexer::Lexer, Parser, StringInput, Syntax};
// use testing::string_errors;

mod bundler;
mod emitter;

fn main() {
    // bundler::bundle();
    emitter::emmit();
    // println!("Hello, world!");

    // work
    // let cm: Lrc<SourceMap> = Default::default();

    // let fm = cm
    //     .load_file(Path::new("src/sample.ts"))
    //     .expect("failed to load sample.ts");

    // let lexer = Lexer::new(
    //     // We want to parse ecmascript
    //     Syntax::Typescript(Default::default()),
    //     // JscTarget defaults to es5
    //     Default::default(),
    //     StringInput::from(&*fm),
    //     None,
    // );

    // let mut parser = Parser::new_from(lexer);
    // let res = parser.parse_module().unwrap();
    // // let out = parse_then_emit(from, Config { minify: true }, Syntax::default());

    // let f = std::fs::File::create("./t.ts").unwrap();
    // let r = Emitter {
    //     cfg: Default::default(),
    //     cm: cm.clone(),
    //     wr: Box::new(text_writer::JsWriter::new(cm.clone(), "\n", f, None)),
    //     comments: None,
    // }
    // .emit_module(&res)
    // .unwrap();
    // work

    // println!("{:?}", v);

    // let out = Builder {
    //     cfg: Default::default(),
    //     cm,
    //     comments,
    // }
    // .text(from, |e| e.emit_module(&res).unwrap());

    // let out = parse_then_emit(res, Default::default(), Syntax::default());
    // let fm = cm.new_source_file(
    //     FileName::Custom("test.js".into()),
    //     parser.parse_script().unwrap().body,
    // );
}

// fn parse_then_emit(from: &str, cfg: Config, syntax: Syntax) -> String {
//     let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));
//     // let (handler, errors) = string_errors::new_handler(cm.clone(), treat_err_as_bug);
//     let src = cm.new_source_file(FileName::Real("custom.js".into()), from.to_string());

//     println!(
//         "--------------------\nSource: \n{}\nPos: {:?} ~ {:?}\n",
//         from, src.start_pos, src.end_pos
//     );

//     let comments = Default::default();
//     let res = {
//         let mut parser = Parser::new(syntax, StringInput::from(&*src), Some(&comments));
//         let res = parser
//             .parse_module()
//             .map_err(|e| e.into_diagnostic(handler).emit());

//         for err in parser.take_errors() {
//             err.into_diagnostic(handler).emit()
//         }

//         res?
//     };

//     let out = Builder { cfg, cm, comments }.text(from, |e| e.emit_module(&res).unwrap());
//     Ok(out)
// }
// ----------------------------  End Main

//------------------------------ BUNDLER
use anyhow::{Error, Result};
use std::path::Path;
use swc_common::sync::Lrc;
use swc_common::{
    errors::{ColorConfig, Handler},
    FileName, FilePathMapping, SourceFile, SourceMap,
};
use swc_ecma_ast::{ImportDecl, Module, ModuleDecl, ModuleItem, Program};
use swc_ecma_codegen::{text_writer, Config, Emitter};
use swc_ecma_parser::{lexer::Lexer, JscTarget, Parser, StringInput, Syntax};
// use testing::string_errors;

pub fn bundle() {
    let res = parse_js("test/index.js").unwrap();
    res.body
        .iter()
        .filter_map(|item| match item {
            ModuleItem::ModuleDecl(ModuleDecl::Import(decl)) => Some(decl),
            _ => None,
        })
        .collect::<Vec<&ImportDecl>>();

    println!("{:#?}", res.body);
}

pub fn parse_js(path: &str) -> Result<Module> {
    let cm: Lrc<SourceMap> = Default::default();
    let fm = cm
        .load_file(Path::new(path))
        .expect("failed to load index.js");
    let lexer = Lexer::new(
        Syntax::Es(Default::default()),
        Default::default(),
        StringInput::from(&*fm),
        None,
    );
    Parser::new_from(lexer)
        .parse_module()
        .map_err(|_| Error::msg("failed to parse module"))
}

struct ModuleData {
    pub fm: Lrc<SourceFile>,
    pub module: Module,
}

struct Compiler {}
impl Compiler {
    pub fn print() {}
}

struct Loader {}
impl Loader {
    pub fn new(compiler: Compiler) {}

    // fn load(&self, name: &String) -> Result<ModuleData, Error> {
    //     let fm = self
    //         .compiler
    //         .cm
    //         .load_file(name)
    //         .with_context(|| format!("failed to load file `{}`", name))?;

    //     let program = {
    //         let mut config = self.compiler.config_for_file(
    //             &swc::config::Options {
    //                 config: {
    //                     if let Some(c) = &self.options.config {
    //                         Some(swc::config::Config {
    //                             jsc: JscConfig {
    //                                 transform: {
    //                                     if let Some(c) = &c.jsc.transform {
    //                                         Some(TransformConfig {
    //                                             react: c.react.clone(),
    //                                             const_modules: c.const_modules.clone(),
    //                                             optimizer: None,
    //                                             legacy_decorator: c.legacy_decorator,
    //                                             decorator_metadata: c.decorator_metadata,
    //                                             hidden: Default::default(),
    //                                         })
    //                                     } else {
    //                                         None
    //                                     }
    //                                 },
    //                                 external_helpers: true,
    //                                 ..c.jsc
    //                             },
    //                             module: None,
    //                             minify: Some(false),
    //                             ..c.clone()
    //                         })
    //                     } else {
    //                         None
    //                     }
    //                 },
    //                 skip_helper_injection: true,
    //                 disable_hygiene: false,
    //                 disable_fixer: true,
    //                 global_mark: self.options.global_mark,
    //                 cwd: self.options.cwd.clone(),
    //                 caller: None,
    //                 filename: String::new(),
    //                 config_file: None,
    //                 root: None,
    //                 root_mode: Default::default(),
    //                 swcrc: true,
    //                 swcrc_roots: Default::default(),
    //                 env_name: {
    //                     let s = env::var("NODE_ENV").unwrap_or_else(|_| "development".into());
    //                     s
    //                 },
    //                 input_source_map: InputSourceMap::Bool(false),
    //                 source_maps: None,
    //                 source_file_name: None,
    //                 source_root: None,
    //                 is_module: true,
    //             },
    //             &fm.name,
    //         )?;

    //         log::trace!("JsLoader.load: loaded config");

    //         // We run transform at this phase to strip out unused dependencies.
    //         //
    //         // Note that we don't apply compat transform at loading phase.
    //         let program =
    //             self.compiler
    //                 .parse_js(fm.clone(), JscTarget::Es2020, config.syntax, true, true)?;

    //         log::trace!("JsLoader.load: parsed");

    //         // Fold module
    //         let program = helpers::HELPERS.set(&helpers, || {
    //             swc_ecma_utils::HANDLER.set(&self.compiler.handler, || {
    //                 let program =
    //                     program.fold_with(&mut inline_globals(env_map(), Default::default()));
    //                 let program = program.fold_with(&mut expr_simplifier());
    //                 let program = program.fold_with(&mut dead_branch_remover());

    //                 let program = program.fold_with(&mut config.pass);

    //                 program
    //             })
    //         });

    //         program
    //     };

    //     match program {
    //         Program::Module(module) => Ok(ModuleData {
    //             fm,
    //             module,
    //             helpers,
    //         }),
    //         _ => unreachable!(),
    //     }
    // }
}

struct Bundler {}
impl Bundler {
    pub fn new() {}

    pub fn bundle(&self, fname: String, fpath: String) {}

    pub fn load_transformed(&self, file_name: &String) {}

    pub fn analyze() {}
}
// ------------------------------- END BUNDLER
